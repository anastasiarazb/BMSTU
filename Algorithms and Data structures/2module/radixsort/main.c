#include <stdio.h>
#include <malloc.h>
#define BASE 256 //Основание системы счисления

typedef union Int32 {
    int x;
    unsigned char bytes[4];
} _int32;

void dispersion_sort(int order);
void radix_sort();
int key(int index, int order);

int arrsize;
_int32 *arr;

int main(void)
{
    int i;
    scanf("%d", &arrsize);
    arr = (_int32 *)malloc(arrsize*sizeof(_int32));
    for(i = 0; i < arrsize; ++i) scanf("%d", &arr[i].x);
    radix_sort();
    putchar('\n');
    for(i = 0; i < arrsize; ++i) printf("%d ", arr[i].x);
    free(arr);
    return 0;
}

void dispersion_sort(int order)
{
    int counter[BASE];
    int i;
    int k;
    for (i = 0; i < BASE; ++i) counter[i] = 0;
    for (i = 0; i < arrsize; ++i){
        k = key(i, order);
        ++counter[k];
    }
    for (i = 1; i < BASE; ++i) {
        counter[i] += counter[i-1];
    }
    int temp[arrsize];
    for (i = arrsize-1; i >= 0; --i) {
        k = key(i, order);
        temp[--counter[k]] = arr[i].x;
    }
    for (i = 0; i < arrsize; ++i)
        arr[i].x = temp[i];
}
void radix_sort()
{
    int i;
    for (i = 0; i < 4; ++i)
        dispersion_sort(i);
}
int key(int index, int order)
{
    //Для незнаковых байтов возвращается ключ, равный содержанию байта.
    //Относительно друг друга сортировка производится правильно и для
    //отрицательных чисел, т.к. для чисел с большим модулем беззнаковое значение
    //меньше.
    //Значения знакового байта для отрицательных значений значения лежат в диапазоне
    //[128, 255], а для положительных - [0, 127]
    //Инвертируем знаковый бит. Так как внутри подгрупп положительных и отрицательных
    //чисел прибавляется константа, то внутри каждой подгруппы сохраняется верный порядок.
    //А диапазоны подгрупп меняются.
    int k = arr[index].bytes[order];
    if (order < 3){
        return k;
    }
    else return (k < 128) ? (128 + k) : (k - 128);
}

/*Суть сортировки по сатршему байту.
Т.к. Числа представлены в доп. коде, то число хранится как 2^32 - k.
Т.е. чем больше |-k|, тем меньше хранящееся в байте число => среди отрицательных
чисел обыкновенная сортировка производится правильно, т.е. расставляя числа по
возрастанию хранящихся в байтах беззнаковых чисел, программа правильно расставляет
их по уменьшению модуля числа.
Нужно, чтобы программа расставляла положительные числа после отрицательных, сохраняя
при этом правильный порядок внутри положительных и отрицательных чисел.
Получается, что отрицательные числа хранятся в диапазоне значений [128, 255]
а положительные - [0, 127]. Для правильно сортировки, нужно, чтобы key возвращала
ключи, с инвертированным знаковым битом.
-8, -5, 5, 6         //Естественное представление
256-8, 256-5, 5, 6   //Хранение в памяти
248, 251, 5, 6
128+120, 128+123, 133-128, 134-128
-5 = 256-5 = 251

00011111    -8
11011111    -5
10100000     5
01100000     6

00011111   248
11011111   251

С инвертированным знаковым битом:
00011110   120  (248-128)
11011110   123  (251-128)
10100001   133  (128+5)
01100001   134  (128+6)
(little-endian, старшие биты справа*/

/*
 *Тем самым подразумевается, что целые числа представлены в системе счисления
 по основанию 256. Доступ к отдельным байтам целого числа должен осуществляться
 через поле bytes объединения.

Замечание. Следует помнить, что байты, из которых состоит целое число,
расположены в памяти в обратном порядке (little-endian). Кроме того, числа
представлены в дополнительном коде, поэтому сортировка по старшему байту, в
котором находится знаковый бит, оличается от сортировки по другим разрядам
числа.
valgrind --leak-check=full ~/Qt/2module/radixsort-Debug/radixsort
5 257 4 2 268 3
5    1000 700 -5000 2038 0
6   2 6 -4 -5000 -3 256
 */
