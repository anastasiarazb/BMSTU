1

Кратчайшая суперстрока
Условие
Баллы: 3

Пусть дано множество из n строк, где 0 < n ≤ 10. Известно, что ни одна из этих строк не является подстрокой другой строки. Составьте программу superstr.c, вычисляющую длину кратчайшей строки, содержащей все эти строки в качестве подстрок.

Программа должна считывать из стандартного потока ввода число n, а затем n строк. Длина кратчайшей строки, содержащей все n считанных строк, должна выводиться в стандартный поток вывода.

Примеры работы программы:
		

№№
	

Ввод
	

Вывод
		
		

1
	
3 
caacccca 
accaacccc 
cabaccaac

	
13

		

2
	
5 
bba 
babccaab 
abccaabac 
aabacacab 
acabaab

	
18

		

3
	
10 
acbabcaac 
cbca 
bbaa 
bcacaab 
acbcccab 
bcbcbab 
bbbccbabca 
accccabba 
cbaca 
accaabaaab

	
60

		

************************************
2

Суммы, образующие степени двойки
Условие
Баллы: 3

Пусть дана последовательность из n неповторяющихся целых чисел, где 0 < n ≤ 24, и каждое целое число находится в диапазоне от -106 до 106. Составьте программу power2.c, вычисляющую, сколько существует непустых сочетаний чисел из последовательности таких, что сумма чисел в сочетании равна степени числа 2.

Программа должна считывать из стандартного потока ввода число n, а затем n чисел, образующих последовательность. Программа должна выводить количество сочетаний в стандартный поток вывода.

Примеры работы программы:
		

№№
	

Ввод
	

Вывод
		
		

1
	
1 
5

	
0

		

2
	
3 
5 3 8

	
3

		

3
	
6 
1 2 3 4 5 6

	
11 



****************************
3
В классической сортировке пузырьком проход по сортируемой последовательности осуществляется всегда в одном направлении. Модифицируйте алгоритм сортировки пузырьком, чтобы в нём чередовались проходы по последовательности слева направо и справа налево.

Составьте функцию bubblesort, осуществляющую двунаправленную пузырьковую сортировку произвольной последовательности. Функция должна быть объявлена как
void bubblesort(unsigned long nel, 
        int (*compare)(unsigned long i, unsigned long j), 
        void (*swap)(unsigned long i, unsigned long j)) 
{ 
        ... 
}

Параметры функции bubblesort:

    nel – количество элементов в последовательности;
    compare – указатель на функцию сравнения, которая возвращает -1, если i-тый элемент меньше j-того, 0 – в случае, если i-тый элемент равен j-тому, и 1 – в случае, если i-тый элемент больше j-того;
    swap – указатель на функцию обмена i-того и j-того элементов последовательности.

Проверка работоспособности функции bubblesort будет осуществляться путём присоединения её к программе вида
#include <stdlib.h> 
#include <stdio.h> 
 
int *array; 
 
int compare(unsigned long i, unsigned long j) 
{ 
        if (i <= j) { 
                printf("COMPARE␣%d␣%d\n", i, j); 
        } else { 
                printf("COMPARE␣%d␣%d\n", j, i); 
        } 
 
        if (array[i] == array[j]) return 0; 
        return array[i] < array[j] ? -1 : 1; 
} 
 
void swap(unsigned long i, unsigned long j) 
{ 
        if (i <= j) { 
                printf("SWAP␣%d␣%d\n", i, j); 
        } else { 
                printf("SWAP␣%d␣%d\n", j, i); 
        } 
 
        int t = array[i]; 
        array[i] = array[j]; 
        array[j] = t; 
} 
 
void bubblesort(unsigned long, 
        int (*)(unsigned long, unsigned long), 
        void (*)(unsigned long, unsigned long)); 
 
int main(int argc, char **argv) 
{ 
        int i, n; 
        scanf("%d", &n); 
 
        array = (int*)malloc(n * sizeof(int)); 
        for (i = 0; i < n; i++) scanf("%d", array+i); 
 
        bubblesort(n, compare, swap); 
        for (i = 0; i < n; i++) printf("%d␣", array[i]); 
        printf("\n"); 
 
        free(array); 
        return 0; 
}

Замечание.
    Отправляемое на проверку решение не должно содержать функцию main. Функция bubblesort должна быть объявлена в точности так, как указано в условии.


4
Функция сортировки методом Шелла
Условие
Баллы: 1

В классической сортировке втавками для вставки элемента в отсортированную часть последовательности выполняется сравнение элемента со всеми членами отсортированной части до тех пор, пока для него не будет найдено место, то есть переменная loc (см. алгоритм в лекциях) на каждой итерции внутреннего цикла уменьшается на единицу.

Метод Шелла является модификацией сортировки вставками, в которой переменная loc на каждой итерции внутреннего цикла уменьшается на некоторое число d ≥ 1. При этом фактически сортировка выполняется несколько раз для всё меньших и меньших значений d до тех пор, пока d не станет равно 1. Тем самым, сначала выполняется серия «грубых» сортировок, которые не дают точного ответа, но делают последовательность более упорядоченной, обеспечивая более быстрое выполнение финальной точной сортировки при d = 1.

Составьте функцию shellsort, выполняющую сортировку произвольной последовательности методом Шелла. Функция shellsort должна быть объявлена как
void shellsort(unsigned long nel, 
        int (*compare)(unsigned long i, unsigned long j), 
        void (*swap)(unsigned long i, unsigned long j)) 
{ 
        ... 
}

Параметры функции shellsort:

    nel – количество элементов в последовательности;
    compare – указатель на функцию сравнения, которая возвращает -1, если i-тый элемент меньше j-того, 0 – в случае, если i-тый элемент равен j-тому, и 1 – в случае, если i-тый элемент больше j-того;
    swap – указатель на функцию обмена i-того и j-того элементов последовательности.

Значения расстояния d в ходе работы функции должны образовывать последовательность Фибоначчи (естественно, записанную задом наперёд). Первое значение в этой последовательности должно быть максимальным числом Фибоначчи, которое меньше значения параметра nel.

Проверка работоспособности функции shellsort будет осуществляться путём присоединения её к программе вида
#include <stdlib.h> 
#include <stdio.h> 
 
int *array; 
 
int compare(unsigned long i, unsigned long j) 
{ 
        if (i <= j) { 
                printf("COMPARE␣%d␣%d\n", i, j); 
        } else { 
                printf("COMPARE␣%d␣%d\n", j, i); 
        } 
 
        if (array[i] == array[j]) return 0; 
        return array[i] < array[j] ? -1 : 1; 
} 
 
void swap(unsigned long i, unsigned long j) 
{ 
        if (i <= j) { 
                printf("SWAP␣%d␣%d\n", i, j); 
        } else { 
                printf("SWAP␣%d␣%d\n", j, i); 
        } 
 
        int t = array[i]; 
        array[i] = array[j]; 
        array[j] = t; 
} 
 
void shellsort(unsigned long, 
        int (*)(unsigned long, unsigned long), 
        void (*)(unsigned long, unsigned long)); 
 
int main(int argc, char **argv) 
{ 
        int i, n; 
        scanf("%d", &n); 
 
        array = (int*)malloc(n * sizeof(int)); 
        for (i = 0; i < n; i++) scanf("%d", array+i); 
 
        shellsort(n, compare, swap); 
        for (i = 0; i < n; i++) printf("%d␣", array[i]); 
        printf("\n"); 
 
        free(array); 
        return 0; 
}

Замечание.
    Отправляемое на проверку решение не должно содержать функцию main. Функция shellsort должна быть объявлена в точности так, как указано в условии.

****************************************************
5
Сортировка подсчётом сравнений
Условие
Баллы: 2

Составьте функцию сsort, выполняющую сортировку слов в предложении методом подсчёта сравнений. Слова в предложении разделяются произвольным количеством пробелов. Функция csort должна быть объявлена следующим образом:
void csort(char *src, char *dest) 
{ 
        ... 
}

В качестве параметров функция csort принимает указатель на исходное предложение src и указатель на пустой буфер dest подходящего размера. В результате работы функции в буфер dest записывается новое предложение, состоящее из слов, взятых из исходного предложения и отсортированных в порядке возрастания их длин. При этом слова в новом предложении разделяются одним пробелом.

Рассмотрим пример работы функции csort. Пусть исходное предложение выглядит как

    qqq  www  t  aa rrr  bb  x y zz

Тогда в выходной буфер должно быть записано предложение

    t x y aa bb zz qqq www rrr

Замечание.
    Алгоритм сортировки подсчётом сравнений, реализуемый функцией csort, нужно модифицировть таким образом, чтобы массив count содержал индексы первых букв слов в отсортированном предложении.

Итоговую программу, содержащую как функцию csort, так и функцию main, демонстрирующую работоспособность функции csort, нужно назвать csort.c. Программа должна считывать исходное предложение с клавиатуры. 


*******************************
6
Пирамидальная сортировка
Условие
Баллы: 1

Составьте функцию hsort, выполняющую пирамидальную сортировку произвольного массива. Объявление функции hsort должно быть выполнено по аналогии с функцией qsort:
void hsort(void *base, size_t nel, size_t width, 
        int (*compare)(const void *a, const void *b)) 
{ 
        ... 
}

В качестве параметров функция hsort принимает указатель на начало массива base, количество элементов массива nel, размер одного элемента width и указатель на функцию сравнения compare.

Итоговая программа heapsort.c должна сортировать массив строк в порядке возрастания количества букв a в строке. Программа должна считывать из стандартного потока ввода размер и элементы массива, и выводить в стандартный поток вывода результат сортировки.

Примеры работы программы:
		

№№
	

Ввод
	

Вывод
		
		

1
	
3 
abac 
asdf 
aaaaa

	
asdf 
abac 
aaaaa

		

2
	
4 
abracadabra 
qwerty 
abba 
a

	
qwerty 
a 
abba 
abracadabra 
**********************************************
7

Сортировка слиянием + вставками
Условие
Баллы: 1

Составьте программу mergesort.c, осуществляющую сортировку массива целых чисел в порядке возрастания модуля числа.

В программе должен быть реализован алгоритм сортировки слиянием, рекурсивную функцию которого нужно модифицировать таким образом, чтобы для последовательностей длиной меньше 5 выполнялась сортировка вставками.

Размер и элементы массива должны считываться программой из стандартного потока ввода. Результат сортировки должен быть выведен в стандартный поток вывода. 
******************************************
7
Сортировка слиянием + вставками
Условие
Баллы: 1

Составьте программу mergesort.c, осуществляющую сортировку массива целых чисел в порядке возрастания модуля числа.

В программе должен быть реализован алгоритм сортировки слиянием, рекурсивную функцию которого нужно модифицировать таким образом, чтобы для последовательностей длиной меньше 5 выполнялась сортировка вставками.

Размер и элементы массива должны считываться программой из стандартного потока ввода. Результат сортировки должен быть выведен в стандартный поток вывода. 
8
Быстрая сортировка + сортировка прямым выбором
Условие
Баллы: 2

Составьте программу quicksort.c, осуществляющую сортировку массива целых чисел в порядке возрастания.

В программе должен быть реализован алгоритм быстрой сортировки, рекурсивную функцию которого нужно модифицировать таким образом, чтобы, во-первых, для последовательностей длиной меньше m выполнялась сортировка прямым выбором, а во-вторых, глубина стека вызовов была равна O(lg n), где n – размер массива.

Программа должна считывать со стандартного потока ввода размер массива n, число m и значения элементов массива. В стандартный поток вывода должны выводиться элементы отсортированного массива. 
9
Сортировка букв в строке
Условие
Баллы: 1

Составьте программу dsort.c, осуществляющую сортировку латинских букв в строке в алфавитном порядке (размер строки – до миллиона букв). В программе должен быть реализован алгоритм сортировки распределением.

Например, если введена строка

    encyclopedia

то программа должна выводить в стандартный поток вывода

    accdeeilnopy

Строка вводится с клавиатуры, причём известно, что она содержит только маленькие латинские буквы. 
************************************
10
Поразрядная сортировка дат
Условие
Баллы: 1

Составьте программу datesort.c, осуществляющую сортировку последовательности дат по возрастанию. В программе должен быть реализован алгоритм поразрядной сортировки, адаптированный для случая, когда ключи представляются в системе счисления с основаниями, зависящими от разряда.

В программе сортируемая последовательность должна быть представлена в виде массива структур Date:
struct Date { 
    int Day, Month, Year; 
};

Поле Day может принимать значения от 1 до 31, поле Month – от 1 до 12, а поле Year – от 1970 до 2030.

Последовательность дат считывается из стандартного потока ввода. При этом в самом начале считывается общее количество дат, а каждая дата представляется тройкой чисел

    yyyy mm dd 

Например, если введена последовательность

    5

    2005 01 12

    1977 02 01

    1994 03 01

    2004 02 29

    1977 08 01

то программа должна выводить в стандартный поток вывода

    1977 02 01

    1977 08 01

    1994 03 01

    2004 02 29

    2005 01 12

11
Поразрядная сортировка целых чисел
Условие
Баллы: 2

Составьте программу radixsort.c, осуществляющую сортировку последовательности 32-разрядных целых чисел по возрастанию. В программе должен быть реализован алгоритм поразрядной сортировки.

Программа должна считывать из стандартного потока ввода размер и элементы последовательности, и записывать в стандартный поток вывода элементы отсортированной последовательности.

Например, если на вход программы подано

    5

    1000 700 -5000 2038 0

то программа должна выводить в стандартный поток вывода

    -5000 0 700 1000 2038

В программе сортируемая последовательность должна быть представлена в виде массива объединений Int32:
union Int32 { 
    int x; 
    unsigned char bytes[4]; 
};

Тем самым подразумевается, что целые числа представлены в системе счисления по основанию 256. Доступ к отдельным байтам целого числа должен осуществляться через поле bytes объединения.

Замечание.
    Следует помнить, что байты, из которых состоит целое число, расположены в памяти в обратном порядке (little-endian). Кроме того, числа представлены в дополнительном коде, поэтому сортировка по старшему байту, в котором находится знаковый бит, оличается от сортировки по другим разрядам числа.
12
Периодические префиксы
Условие
Баллы: 2

Составьте программу prefixes.c, выполняющую поиск всех периодических префиксов заданной строки S. Префикс является периодическим, если его можно представить в виде
d◟d-.◝.◜.d◞ k,
где d – некоторая подстрока. Для поиска префиксов программа должна строить префиксную функцию для строки S.

Программа получает строку S через аргументы командной строки, и для каждого найденного префикса выводит в стандартный поток вывода два числа: длину префикса n и количество повторений k подстроки d в префиксе.

Например, пусть программа вызвана как

    ./prefixes aabaabaabaab

Тогда программа должна выводить в стандартный поток вывода

    2 2

    6 2

    9 3

    12 4
13
Поиск всех вхождений подстроки в строку (Кнут-Моррис-Пратт)
Условие
Баллы: 1

Составьте программу kmpall.c, осуществляющую поиск всех вхождений подстроки S в строку T. В программе должен быть реализован алгоритм Кнута-Морриса-Пратта, изменённый таким образом, чтобы при нахождении очередного вхождения S в T алгоритм не завершался, а продолжал сканировать строку T.

Строки S и T должны передаваться в программу через аргументы командной строки. Программа должна выводить в стандартный поток вывода индексы первых символов всех вхождений S в T. 

***********************************************************8
14
Слово, составленное из префиксов другого слова
Условие
Баллы: 1

Составьте программу pword.c, определяющую, составлена ли строка T исключительно из префиксов строки S.

Программа получает строки S и T через аргументы командной строки и выводит ’yes’, если T составлена из префиксов S, и ’no’ – в противном случае.

Например, пусть программа вызвана как

    ./pword abracadabra abrabracada

Тогда программа должна выводить в стандартный поток вывода

    yes
15
Поиск всех вхождений подстроки в строку (Бойер-Мур)
Условие
Баллы: 2

Составьте программу bmall.c, осуществляющую поиск всех вхождений подстроки S в строку T. В программе должен быть реализован алгоритм Бойера-Мура, изменённый таким образом, чтобы при нахождении очередного вхождения S в T алгоритм не завершался, а продолжал сканировать строку T.

Строки S и T должны передаваться в программу через аргументы командной строки. Программа должна выводить в стандартный поток вывода индексы первых символов всех вхождений S в T. 
*************************
16
Расширенная эвристика стоп-символа
Условие
Баллы: 1

Существует модификация алгоритма Бойера-Мура, в которой эвристика стоп-символа расширена следующим образом:

Расширенная эвристика стоп-символа.
    Встретив в строке T символ x = T[k] такой, что x≠S[i], мы можем расположить строку S относительно строки T так, что последнее вхождение x в S, расположенное левее S[i], окажется напротив T[k]. 
Пример.
    (T[2] = a – стоп-символ)
    	
    	
    0
    	
    1
    	
    2
    	
    3
    	
    4
    	
    5
    	
    6
    	
    7
    	
    8
    	
    9
    	
    …
    T =
    	
    	
    a
    	
    b
    	
    a
    	
    a
    	
    b
    	
    a
    	
    b
    	
    a
    	
    c
    	
    b
    	
    …
    S =
    	
    	
    c
    	
    a
    	
    ⟨b⟩
    	
    a
    	
    b
    	
    	
    	
    c
    	
    a
    	
    b
    	
    a
    	
    b
    	
    	
    	
    	
    	
    	
    .
    	
    .
    	
    .

Таблица δ1 для эффективной реализации расширенной эвристики стоп-символа должна представлять собой матрицу размера len(S) × size, где size – размер алфавита. При неудачном сравнении символов S[i] и T[k] алгоритм Бойера-Мура должен прочитать смещение для переменной k из δ1[i,T [k]].

Составьте программу extstop.c, осуществляющую поиск первого вхождения подстроки S в строку T. В программе должен быть реализован вариант алгоритма Бойера-Мура, в котором не используется эвристика совпавшего суффикса, а эвристика стоп-символа расширена приведённым выше способом.

Строки S и T должны передаваться в программу через аргументы командной строки. Программа должна вывести в стандартный поток вывода индекс первого символа первого вхождения S в T. Если такого вхождения нет, программа должна вывести len(T). 
***************************

17
Поиск максимального элемента подпоследовательности
Условие
Баллы: 2

Составьте программу rangemax.c, выполняющую поиск максимального элемента на различных интервалах последовательности целых чисел, которая время от времени изменяется.
Формат входных данных

Первая строка, считываемая со стандартного потока ввода, содержит размер последовательности n (0 < n ≤ 1000000). Во второй строке перечислены элементы последовательности. Каждый элемент представляет собой целое число, находящееся в диапазоне от -109 до 109. Элементы разделяются пробелами.

Третья строка содержит общее количество выполняемых операций m (0 < m ≤ 20000). Каждая из следующих m строк содержит описание операции.

Операция либо имеет форму MAX l r (найти максимальный элемент подпоследовательности, начинающейся с элемента с индексом l и заканчивающейся элементом с индексом r), либо форму UPD i v (присвоить значение v элементу с индексом i).

Формат результата работы программы

Для каждой операции MAX вывести в стандартный поток вывода значение максимального элемента указанной подпоследовательности.

Пример работы программы
	

Входные данные
	

Выходные данные
	
	
5 
10 2 -5 8 7 
4 
MAX 0 4 
MAX 1 3 
UPD 2 12 
MAX 1 3

	
10 
8 
12 

**********************************
18
Определение гипердромов в строке
Условие
Баллы: 3

Гипердром – это строка, из букв которой можно составить палиндром. Другими словами, любая буква имеет чётное количество вхождений (возможно, нулевое) в гипердром чётной длины. Если же гипердром имеет нечётную длину, то ровно одна буква имеет нечётное количество вхождений.

Составьте программу rangehd.c, определяющую, является ли указанная подстрока строки гипердромом. Строка время от времени может изменяться.
Формат входных данных

Первая строчка, считываемая со стандартного потока ввода, содержит строку размера n (0 < n ≤ 1000000). Строка состоит из маленьких латинских букв.

Вторая строчка содержит общее количество выполняемых операций m (0 < m ≤ 10000). Каждая из следующих m строчек содержит описание операции.

Операция либо имеет форму HD l r (определить, является ли подстрока, начинающаяся с индекса l и заканчивающаяся индексом r, гипердромом), либо форму UPD i s (заменить подстроку, начинающуюся с индекса i, строкой s).

Формат результата работы программы

Для каждой операции HD вывести в стандартный поток вывода слово «YES», если подстрока является гипердромом, или слово «NO» в противном случае.

Пример работы программы
	

Входные данные
	

Выходные данные
	
	
aababab 
6 
HD 0 6 
HD 1 6 
HD 0 3 
UPD 2 qqq 
HD 0 6 
HD 1 5

	
YES 
NO 
NO 
NO 
YES 
***************************
19
Количество пиков в подпоследовательности
Условие
Баллы: 2

Напомним, что элемент последовательности чисел, значение которого – не меньше значений его непосредственных соседей, называется пиком.

Составьте программу rangepeak.c, выполняющую вычисление количества пиков на различных интервалах последовательности целых чисел, которая время от времени изменяется.
Формат входных данных

Первая строка, считываемая со стандартного потока ввода, содержит размер последовательности n (0 < n ≤ 1000000). Во второй строке перечислены элементы последовательности. Каждый элемент представляет собой целое число, находящееся в диапазоне от -109 до 109. Элементы разделяются пробелами.

Третья строка содержит общее количество выполняемых операций m (0 < m ≤ 20000). Каждая из следующих m строк содержит описание операции.

Операция либо имеет форму PEAK l r (вычислить количество пиков в подпоследовательности, начинающейся с элемента с индексом l и заканчивающейся элементом с индексом r), либо форму UPD i v (присвоить значение v элементу с индексом i).

Формат результата работы программы

Для каждой операции PEAK вывести в стандартный поток вывода количество пиков в указанной подпоследовательности.

Пример работы программы
	

Входные данные
	

Выходные данные
	
	
5 
1 2 3 4 3 
6 
PEAK 0 4 
PEAK 0 2 
PEAK 4 4 
UPD 3 2 
PEAK 0 4 
PEAK 0 2

	
1 
0 
0 
2 
1 
**************************
20
Наибольший общий делитель подпоследовательности
Условие
Баллы: 3

Составьте программу rangegcd.c, вычисляющую наибольший общий делитель на различных интервалах последовательности целых чисел.
Формат входных данных

Первая строка, считываемая со стандартного потока ввода, содержит размер последовательности n (0 < n ≤ 300000). Во второй строке перечислены элементы последовательности. Каждый элемент представляет собой целое число, находящееся в диапазоне от -109 до 109. Элементы разделяются пробелами.

Третья строка содержит общее количество запросов m (0 < m ≤ 1000000). Каждая из следующих m строк содержит запрос, который представляет собой два числа l и r, задающие границы интервала, на котором нужно вычислить наименьший общий делитель (0 ≤ l,r < n).

Формат результата работы программы

Для каждого запроса вывести в стандартный поток вывода наименьший общий делитель указанной подпоследовательности.

Пример работы программы
	

Входные данные
	

Выходные данные
	
	
10 
-10 -2 5 60 80 100 77 65 33 45 
6 
0 9 
0 1 
2 5 
3 5 
6 8 
8 9

	
1 
2 
5 
20 
1 
3

	
**********************************
21
Максимальное произведение простых дробей
Условие
Баллы: 3

Составьте программу maxprod.c, выполняющую поиск отрезка последовательности простых дробей {v }n-1 i 0, на котором произведение дробей максимально.
Формат входных данных

Первая строка, считываемая со стандартного потока ввода, содержит размер последовательности n (0 < n ≤ 1000000). Во второй строке перечислены элементы последовательности. Каждый элемент записывается в виде a∕b, где a и b – неотрицательные целые числа (0 ≤ a ≤ 1000000, 0 < b ≤ 1000000). Элементы разделяются пробелами.

Формат результата работы программы

Программа должна вывести в стандартный поток вывода два числа l и r такие, что произведение ∏r vi i=l – максимально. Если возможно несколько решений, следует выбрать решение с минимальным l.

Пример работы программы
	

Входные данные
	

Выходные данные
	
	
10 
4/3 2/1 8/3 0/1 10/3 8/3 1/10 1/5 50/7 1/8

	
4 5

	 
