/* Так как все четные числа составные, кроме 2, можно сразу пропускать
каждое второе число. И массив чисел будет иметь длину не х, а х/2, то есть в
худшем случае - 2^30, а не 2^31. Тогда последовательность будет выглядеть как
2, 3, 5, 7... Если делать не массив чисел, а массив битов, то памяти будет
занято еще в 8 раз меньше, то есть максимум 2^27 байтов.
   Тогда битовый массив будет составлен таким образом, что i-й бит обозначает
число 2i+1 (так как мы берем только нечетные числа), кроме 0-го бита, в котором
"лежит" 2, а не 1.
   Если d — делитель n, то n/d тоже. Но d и n/d не могут оба быть больше √n =>
можно заполнить решето только до √n, а после воспользоваться основной теоремой
арифметики: каждое число можно представить в виде единственного разложения на
простые множители - и если наибольший простой делитель больше, чем √n, деля
последовательно n на меньшие простые делители, мы получим наибольший простой
делитель. Если он присутствует в разложении числа больше 1 раза т.е. (т =
p1...pmax^2), то он будет меньше либо равен √n.
     Тогда мы заполняем решето длины (√n)/2/8, так, чтобы в битовом массиве
i-й бит был равен 1, если число 2i+1 составное (изначально массив нулевой, для
каждого последующего бита i равного нулю "включаем" кратные ему числа, расположенные
в ячейках i+k(2i+1), после чего последовательно делим число на простые делители из
массива. */

#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#define IS_BIT_ON(bit) ((arr[(bit)/8] >> ((bit) % 8)) & 1)  // Нужный бит находится в bit/8 байте
                                                            // массива на bit % 8 месте
#define SET_BIT_ON(bit) {arr[(bit)/8] |= (1 << ((bit) % 8));} // Пометить число как составное
#define NUMBER(bit) ((bit) ? (2*(bit)+1) : 2)                 // 0-й бит исключение, он хранит 2-ку, а не 1

void erat_sieve(int arr_len);
int biggest_divisor(int x, int arr_len);

char *arr;

int main(void)
{
    int x;
    scanf("%d", &x);
    x = abs(x);
    int arr_len = ((sqrt(x) + 1)/16) + 1;
    arr = (char *)calloc(arr_len, 1);
    erat_sieve(arr_len);
    printf("%d\n", biggest_divisor(x, arr_len));
    free(arr);
    return 0;
}

void erat_sieve(int arr_len)
{
    int i, j;   //Счетчик битов
    for(i = 1; i < 8 * arr_len; ++i){
        if (IS_BIT_ON(i)) continue;       //Число составное
        for(j = i + 2*i+1; j < 8 * arr_len; j += 2*i+1) {
            SET_BIT_ON(j);
        }
    }
}

int biggest_divisor(int x, int arr_len)
{
    int i;
    // Раскладываем число на простые множители
    for(i = 0; i < 8 * arr_len; ++i){
        if (IS_BIT_ON(i)) continue;       //Число составное, не является простым делителем
        while((! (x % NUMBER(i)))&& x/NUMBER(i) > 1){
            x /= NUMBER(i);
        }
    }
    return x;
}

//valgrind /home/nastasia/Qt/1module/7-primediv-Debug/7-primediv
